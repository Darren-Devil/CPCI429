/*++

Module Name:

    device.c - Device handling events for example driver.

Abstract:

   This file contains the device entry points and callbacks.
    
Environment:

    Kernel-mode Driver Framework

--*/

#include "driver.h"
#include "device.tmh"

#pragma warning(disable:4013) 
#pragma warning(disable:4100) 
#pragma warning(disable:4189)

#ifdef ALLOC_PRAGMA
#pragma alloc_text (PAGE, CPCI429CreateDevice)
#pragma alloc_text (PAGE, CPCI429EvtDevicePrepareHardware)
#pragma alloc_text (PAGE, CPCI429EvtDeviceReleaseHardware)
#pragma alloc_text (PAGE, CPCI429EvtDeviceD0Entry)
#pragma alloc_text (PAGE, CPCI429EvtDeviceD0Exit)
#endif

NTSTATUS
CPCI429CreateDevice(
	_Inout_ PWDFDEVICE_INIT DeviceInit
)
/*++

Routine Description:

Worker routine called to create a device and its software resources.

Arguments:

DeviceInit - Pointer to an opaque init structure. Memory for this
structure will be freed by the framework when the WdfDeviceCreate
succeeds. So don't access the structure after that point.

Return Value:

NTSTATUS

--*/
{
	WDF_OBJECT_ATTRIBUTES deviceAttributes;
	PDEVICE_CONTEXT deviceContext;
	WDFDEVICE device;
	NTSTATUS status;

	PAGED_CODE();

	WDF_OBJECT_ATTRIBUTES_INIT_CONTEXT_TYPE(&deviceAttributes, DEVICE_CONTEXT);

	status = WdfDeviceCreate(&DeviceInit, &deviceAttributes, &device);

	if (NT_SUCCESS(status)) {
		//
		// Get a pointer to the device context structure that we just associated
		// with the device object. We define this structure in the device.h
		// header file. DeviceGetContext is an inline function generated by
		// using the WDF_DECLARE_CONTEXT_TYPE_WITH_NAME macro in device.h.
		// This function will do the type checking and return the device context.
		// If you pass a wrong object handle it will return NULL and assert if
		// run under framework verifier mode.
		//
		deviceContext = DeviceGetContext(device);

		//
		// Initialize the context.
		//
		deviceContext->PrivateDeviceData = 0;

		//
		// Create a device interface so that applications can find and talk
		// to us.
		//
		status = WdfDeviceCreateDeviceInterface(
			device,
			&GUID_DEVINTERFACE_CPCI429,
			NULL // ReferenceString
		);

		if (NT_SUCCESS(status)) {
			//
			// Initialize the I/O Package and any Queues
			//
			status = CPCI429QueueInitialize(device);
		}
	}

	return status;
}

NTSTATUS
CPCI429EvtDevicePrepareHardware(
	IN WDFDEVICE Device,
	IN WDFCMRESLIST ResourceList,
	IN WDFCMRESLIST ResourceListTranslated
)
{
	ULONG i;
	NTSTATUS status = STATUS_SUCCESS;
	PDEVICE_CONTEXT pDeviceContext;

	PCM_PARTIAL_RESOURCE_DESCRIPTOR descriptor;

	PAGED_CODE();

	pDeviceContext = DeviceGetContext(Device);
	pDeviceContext->MemBaseAddress = NULL;
	pDeviceContext->Counter_i = 0;
	//获取资源
	for (i = 0; i < WdfCmResourceListGetCount(ResourceListTranslated); i++) {
		descriptor = WdfCmResourceListGetDescriptor(ResourceListTranslated, i);
		if (!descriptor) {
			return STATUS_DEVICE_CONFIGURATION_ERROR;
		}

		switch (descriptor->Type) {
		case CmResourceTypeMemory:
			//MmMapIoSpace将物理地址转换为系统内核模式地址（虚拟地址）
			if (i == 0) {
				pDeviceContext->PhysicalAddressRegister = descriptor->u.Memory.Start.LowPart;
				pDeviceContext->BAR0_VirtualAddress = MmMapIoSpace(
					descriptor->u.Memory.Start,
					descriptor->u.Memory.Length,
					MmNonCached);
			}//地址映射
			pDeviceContext->MemBaseAddress = MmMapIoSpace(
				descriptor->u.Memory.Start,
				descriptor->u.Memory.Length,
				MmNonCached
			);
			pDeviceContext->MemLength = descriptor->u.Memory.Length;
			break;

		default:
			break;
		}
		if (!pDeviceContext->MemBaseAddress) {
			return STATUS_INSUFFICIENT_RESOURCES;
		}
	}
	pDeviceContext->Counter_i = i;
	DbgPrint("EvtDevicePrepareHardware - ends\n");

	return STATUS_SUCCESS;
}
NTSTATUS
CPCI429EvtDeviceReleaseHardware(
	IN WDFDEVICE Device,
	IN WDFCMRESLIST ResourceListTranslated
)
{
	PDEVICE_CONTEXT pDeviceContext = NULL;

	PAGED_CODE();

	DbgPrint("EvtDeviceReleaseHardware - begins\n");

	pDeviceContext = DeviceGetContext(Device);

	if (pDeviceContext->MemBaseAddress) {
		//MmUnmalIoSpace解除物理地址与系统内核地址(虚拟地址)的关联
		MmUnmapIoSpace(pDeviceContext->MemBaseAddress, pDeviceContext->MemLength);
		pDeviceContext->MemBaseAddress = NULL;
	}

	DbgPrint("EvtDeviceReleaseHardware - ends\n");

	return STATUS_SUCCESS;
}

NTSTATUS
CPCI429EvtDeviceD0Entry(
	IN WDFDEVICE Device,
	IN WDF_POWER_DEVICE_STATE PreviousState
)
{
	UNREFERENCED_PARAMETER(Device);
	UNREFERENCED_PARAMETER(PreviousState);

	return STATUS_SUCCESS;
}

NTSTATUS
CPCI429EvtDeviceD0Exit(
	IN WDFDEVICE Device,
	IN WDF_POWER_DEVICE_STATE TargetState
)
{
	UNREFERENCED_PARAMETER(Device);
	UNREFERENCED_PARAMETER(TargetState);

	PAGED_CODE();

	return STATUS_SUCCESS;
}

